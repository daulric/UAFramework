<roblox version="4">
  <Item class="DataModel" referent="0">
    <Properties>
      <string name="Name">UA Framework</string>
    </Properties>
    <Item class="ReplicatedFirst" referent="1">
      <Properties>
        <string name="Name">ReplicatedFirst</string>
      </Properties>
      <Item class="LocalScript" referent="2">
        <Properties>
          <string name="Name">Testing</string>
          <string name="Source">local UAF = require(game:GetService("ReplicatedStorage"):WaitForChild("UAFramework"))
local Storage = UAF.Storage
local Player = game.Players.LocalPlayer

local Stored = Storage.createStorage('hello')

Stored:dump(
    "hello"
)

print("Storage First:", Stored:grab(), "- Previous:", Storage:GetStorageInfo())

Stored:UpdateStorage(function(oldData)
    local Data = {
        BitCoins = 10,
        Coins = 100,
        Etherium = 1000,
        Fake = "fake",
        oldData
    }

    return Data
end)

print(Stored:find("hello"))
print("Updated Storage:", Stored:grab(), "- After:", Storage:GetStorageInfo())</string>
        </Properties>
      </Item>
    </Item>
    <Item class="ReplicatedStorage" referent="3">
      <Properties>
        <string name="Name">ReplicatedStorage</string>
      </Properties>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">UAFramework</string>
          <string name="Source">local module = {}
local ServerApi = script:WaitForChild("ServerApi")
local GlobalApi = script:WaitForChild("GlobalApi")
local ClientApi = script:WaitForChild("ClientApi")
local AdvancedDataTypes = script:WaitForChild("AdvancedDataTypes")
local RS = game:GetService("RunService")

export type ClientClass = "GuiClass" | "InputClass"
export type ServerClass = "Team"
export type GlobalClass = "Event"
export type AdvancedDataTypes = "NTS" | "Numbers"
-- Final Export on Class
export type Service = ClientClass | ServerClass | GlobalClass | AdvancedDataTypes

-- Global Api
module.Event = require(GlobalApi.UAEvent)
module.Storage = require(GlobalApi.Storage)

-- Advanced Data Types
module.NTS = require(AdvancedDataTypes.NumberToString)
module.Numbers = require(AdvancedDataTypes.Numbers)


print(script.Name, "| Loading Global Api")

print("we are ulric")

if RS:IsClient() then
	module.GuiClass = require(ClientApi.GuiClass)
	module.InputClass = require(ClientApi.InputClass)
	script:SetAttribute("Client", true)
	script:SetAttribute("Server", nil)
	print(script.Name, "| Loading Client Api")
end

if RS:IsServer() then
	module.Team = require(ServerApi.TeamClass)
	module.IsServer = require(ServerApi.IsServer)
	script:SetAttribute("Server", true)
	print(script.Name, "| Loading Server Api")
end

print(script.Name, "| Finished Loading")

return module</string>
        </Properties>
        <Item class="Folder" referent="5">
          <Properties>
            <string name="Name">AdvancedDataTypes</string>
          </Properties>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">NumberToString</string>
              <string name="Source">local module = {}

local Abbreviations = {
	K = 4,
	M = 7,
	B = 10,
	T = 13,
	Qa = 16,
	Qu = 19,
}

function module:ConvertToMoney(number: number)
	return require(script.ConvertToMoney)(number)
end

function module:ConvertToTime(Time: number)
	return require(script.ConvertToTime)(Time)
end

function module:RoundNumber(num)
	local GetTotal = num
	return GetTotal % 1 >= 0.5 and math.ceil(GetTotal) or math.floor(GetTotal)
end

return module</string>
            </Properties>
            <Item class="ModuleScript" referent="7">
              <Properties>
                <string name="Name">ConvertToMoney</string>
                <string name="Source">local Abbreviations = {
	K = 4,
	M = 7,
	B = 10,
	T = 13,
	Qa = 16,
	Qu = 19,
}

return function(number)
	if not (type(number) == "number") then
		return "error: "..number
	end

	local text = tostring(math.floor(number))
	local dummyText = ""

	local chosenAbbreviation

	for abbreviation, digits in pairs(Abbreviations) do
		if #text >= digits and #text &lt; (digits + 3) then
			chosenAbbreviation = abbreviation
			break
		end
	end

	if  chosenAbbreviation then
		local digits = Abbreviations[chosenAbbreviation]
		local rounded = math.floor(number / 10 ^ (digits - 2)) * 10 ^ (digits - 2)
		text = string.format("%.1f", rounded / 10 ^ (digits - 1))..chosenAbbreviation
		return text
	else
		return text
	end
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="8">
              <Properties>
                <string name="Name">ConvertToTime</string>
                <string name="Source">return function(Time)
	local minute = tostring(math.floor(Time/60))
	local sec = math.floor(Time%60)

	if sec &lt; 10 then
		sec = "0".. tostring(math.floor(Time%60))
	end

	return minute..":"..sec
end</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">Numbers</string>
              <string name="Source">local module = {}

function module:IsEven(num)
	local Factor = (num % 2)

	if Factor == 0 then
		return true
	end

	return false
	
end

function module:GetAverage(...)
	return require(script.GetAverage)(...)
end

function module:Add(...: number)
	return require(script.Add)(...)
end

function module:Multiply(...: number)
	return require(script.Multiply)(...)
end

return module</string>
            </Properties>
            <Item class="ModuleScript" referent="10">
              <Properties>
                <string name="Name">Add</string>
                <string name="Source">return function (...: number)
    local NewTable = table.pack(...)
    NewTable.n = nil
    local sum = 0;

    for index, value in pairs(NewTable) do
        sum = sum + value
    end

    print(NewTable)
    return sum
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="11">
              <Properties>
                <string name="Name">GetAverage</string>
                <string name="Source">return function(...)
	local GetData = table.pack(...)
	local sum = 0
	
	for i, v in pairs(GetData) do
		if not (type(...) == "number") then
			warn("There is no number", "Please fix!")
			return
		end
		
		if i ~= "n" then
			sum = (sum + v)
		end
	end
	
	local GetTotal = (sum / GetData.n)
	
	return GetTotal % 1 >= 0.5 and math.ceil(GetTotal) or math.floor(GetTotal)
	
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="12">
              <Properties>
                <string name="Name">Multiply</string>
                <string name="Source">return function (...: number)
    local NewTable = table.pack(...)
    NewTable.n = nil
    local Total = 1

    for index, value in pairs(NewTable) do
        Total = (Total * value)
    end

    return Total

end</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="13">
          <Properties>
            <string name="Name">ClientApi</string>
          </Properties>
          <Item class="ModuleScript" referent="14">
            <Properties>
              <string name="Name">GuiClass</string>
              <string name="Source">local module = {}
local Event = script:FindFirstChildOfClass("BindableEvent")

function module:EditTextButton(gui: TextButton, Settings)
	
	if not (typeof(Settings) == "table") then
		warn("This is not a table")
		return
	end
	
	if Settings.Text ~= nil then
		gui.Text = Settings.Text
	end
	
	if Settings.Background ~= nil then
		gui.BackgroundColor3 = Settings.Background
	end
	
	local connection
	if Settings.Callback ~= nil then
		connection = gui.MouseButton1Click:Connect(Settings.Callback)
	end
	
	if Settings.MouseEnterCallback ~= nil then
		connection = gui.MouseEnter:Connect(Settings.MouseEnterCallback)
	end
	
	if Settings.MouseExitCallback ~= nil then
		connection = gui.MouseLeave:Connect(Settings.MouseExitCallback)
	end
	
	function Settings:Stop()
		if connection then
			warn("Callback is Disconnecting")
			return connection:Disconnect()
		end
	end
	
	return Settings
end

function module:EditImageButton(gui: ImageButton, Settings)
	if not (typeof(Settings) == "table") then
		warn("This is not a table")
		return
	end
	
	if Settings.Image ~= nil then
		gui.Image = Settings.Image
	end
	
	if Settings.HoverImage ~= nil then
		gui.HoverImage = Settings.HoverImage
	end
	
	if Settings.Background ~= nil then
		gui.BackgroundColor3 = Settings.Background
	end
	
	local Connection
	if Settings.Callback ~= nil then
		Connection = gui.MouseButton1Click:Connect(Settings.Callback)
	end
	
	if Settings.MouseEnterCallback ~= nil then
		Connection = gui.MouseEnter:Connect(Settings.MouseEnterCallback)
	end

	if Settings.MouseExitCallback ~= nil then
		Connection = gui.MouseLeave:Connect(Settings.MouseExitCallback)
	end
	
	function Settings:Stop()
		warn("Connection Stoped", "Cant be used")
		Connection:Disconnect()
	end
	
	return Settings
end

function module:EditImage(gui: ImageLabel,Settings)
	if not (typeof(Settings) == "table") then
		warn("this is not a table")
		return
	end
	
	if Settings.Image ~= nil then
		gui.Image = Settings.Image
	end
	
	if Settings.Background ~= nil then
		gui.BackgroundColor3 = Settings.Background
	end
	
	return Settings
end

function module:EditFrame(gui: Frame, Settings)
	if not (typeof(Settings) == "table") then
		warn("this is not a table")
		return
	end

	if Settings.Size ~= nil then
		gui.Size = Settings.Size
	end
	
	if Settings.Transparency ~= nil then
		gui.BackgroundTransparency = Settings.Transparency
	end

	if Settings.Background ~= nil then
		gui.BackgroundColor3 = Settings.Background
	end
	
	if Settings.MouseEnterCallback ~= nil then
		gui.MouseEnter:Connect(Settings.MouseEnterCallback)
	end

	if Settings.MouseExitCallback ~= nil then
		gui.MouseLeave:Connect(Settings.MouseExitCallback)
	end
	
	return Settings
end

function module:EditGeneralButton(gui: GuiButton, Settings)
	if not (typeof(Settings) == "table") then
		warn("This is not a table")
		return
	end

	local connection
	if Settings.Callback ~= nil then
		connection = gui.MouseButton1Click:Connect(Settings.Callback)
	end
	
	if Settings.MouseEnterCallback ~= nil then
		connection = gui.MouseEnter:Connect(Settings.MouseEnterCallback)
	end

	if Settings.MouseExitCallback ~= nil then
		connection = gui.MouseLeave:Connect(Settings.MouseExitCallback)
	end

	function Settings:Stop()
		warn("Connection Stoped", "Cant be used")
		connection:Disconnect()
	end
	
	return Settings
end

return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="15">
            <Properties>
              <string name="Name">InputClass</string>
              <string name="Source">local UserInputService = game:GetService("UserInputService")

local module = {}
local binds = {}

function checkSetting(setting)
	if not (typeof(setting) == "table") then
		warn("this is not a table")
		return
	end
end

function module:CombineKey(name, callback, ...)
	local keys = table.pack(...)
	keys.n = nil

	binds[name] = UserInputService.InputBegan:Connect(function(input, bool)
		if bool then return end
		local KeyCode = (input.KeyCode == keys[#keys])
		if KeyCode then
			for key, _ in pairs(keys) do
				if not UserInputService:IsKeyDown(keys[key]) then
					return
				end
			end
			callback(name)
		end
	end)
end

function module:UnbindKey(name)
	print("action unbind", name)
	binds[name]:Disconnect()
end

function module:BeginInput(Settings)
	UserInputService.InputBegan:Connect(function(input, bool)
		if Settings.Proccessed == true then
			if bool then return end
		end

		if input.KeyCode == Settings.Key then
			Settings.Callback()
		elseif input.UserInputType == Settings.Key then
			Settings.Callback()
		end
	end)
end

function module:EndInput(Settings)
	checkSetting(Settings)
	UserInputService.InputEnded:Connect(function(input, bool)
		if Settings.Proccessed == true then
			if bool then return end
		end

		if input.KeyCode == Settings.Key then
			Settings.Callback()
		elseif input.UserInputType == Settings.Key then
			Settings.Callback()
		end
	end)
end

function module:ChangeInput(Settings)
	checkSetting(Settings)
	UserInputService.InputChanged:Connect(function(input, bool)
		if Settings.Proccessed == true then
			if bool then return end
		end

		if input.KeyCode == Settings.Key then
			Settings.Callback()
		elseif input.UserInputType == Settings.Key then
			Settings.Callback()
		end
	end)
end

return module</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="16">
          <Properties>
            <string name="Name">GlobalApi</string>
          </Properties>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">Storage</string>
              <string name="Source">local module = {}

local Storage = {}

function module.createStorage(id: string)
    local self = {}

    function self:dump(Data)

        for index, _ in (Storage) do
            if index == id then
                warn("there is already an id")
                return
            end
        end

        Storage[id] = Data
    end

    function self:delete()
        if Storage[id] == nil then
            warn("there is nothing stored with", id)
            return
        end
    
        Storage[id] = nil
    end

    function self:grab()
        if Storage[id] == nil then
            warn("there is nothing stored")
            return
        end
    
        return Storage[id]
    end

    function self:find(key)
        if Storage[id] == nil then
            warn("this is nothing stored")
            return
        end

        if not (type(Storage[id]) == "table") then
            warn("You cant request a search if its not a table", "- ID:", id)
            return
        end
    
        for index, value in pairs(Storage[id]) do
            if key == value then
                return value
            end

            if key == index then
                return value
            end

            warn("couldn't find", key)
        end
    end

    function self:UpdateStorage(handler)
        local oldData = Storage[id]
        local Data

        if oldData == nil then
            Data = handler()
        end

        Data = handler(oldData)
        Storage[id] = Data

    end

    return self
end

function module:GetStorageInfo(id)
    if Storage[id] ~= nil then
        return Storage[id]
    end

    return Storage
end

return module</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="18">
            <Properties>
              <string name="Name">UAEvent</string>
              <string name="Source"><![CDATA[local module = {}
local RemoteFunc = script:FindFirstChildOfClass("RemoteFunction")
local RemoteEvent = script:FindFirstChildOfClass("RemoteEvent")
local BindableFunc = script:FindFirstChildOfClass("BindableFunction")
local BindableEvent = script:FindFirstChildOfClass("BindableEvent")
local RS = game:GetService("RunService")

local ErrorMessage = "No Signal Passed"

local Listeners = {}
local Storage = {}

function module:ListenForEvent(id: string, func: RBXScriptSignal)
	if not (type(func) == "function") then
		warn("This is not a function", id)
	end
	
	for i, _ in pairs(Listeners) do
		if i == id then
			warn("there is an id in use. find it and change it!", id)
			return
		end
	end

	local id = ""..id
	local listener = {
		Callback = func,
	}

	function listener:Stop()
		local ReturnSignal = {}
		
		Storage[id] = Listeners[id]
		Listeners[id] = nil
		warn("ID: ", id, "has been disconnected")
		
		function ReturnSignal:Reconnect()
			if Storage[id] == nil then return end
			if Listeners[id] ~= nil then return end
			
			if Listeners[id] == nil then 
				Listeners[id] = Storage[id]
				RS.Heartbeat:Wait()
				Storage[id] = nil
				warn("reconnecting signal")
				return
			end
		end
		
		return ReturnSignal
	end

	Listeners[id] = listener

	return listener
end

function module:DisconnectAll()
	RS.Heartbeat:Connect(function()
		for i, _ in pairs(Listeners) do
			Listeners[i] = nil
		end
	end)
end

function module:SendServer(id: string, ...)
	RemoteEvent:FireServer(id, ...)
end

function module:SendClient(player: Player, id: string, ...)
	RemoteEvent:FireClient(player, id, ...)
end

function module:SendAllClients(id: string, ...)
	RemoteEvent:FireAllClients(id, ...)
end

function module:GetServer(id: string, ...)
	return RemoteFunc:InvokeServer(id, ...)
end

function module:GetClient(player: Player, id: string, ...)
	return RemoteFunc:InvokeClient(player, id, ...)
end

function module:FireDataToCom(id: string, ...)
	BindableEvent:Fire(id, ...)
end

function module:GetDataFromCom(id: string, ...)
	return BindableFunc:Invoke(id, ...)
end

function OnServerListen(player: Player, id: string, ...)
	if Listeners[id] == nil then
		warn(ErrorMessage, "Server_Error", id)
		return
	end

	if Listeners[id] then
		return Listeners[id].Callback(player,...)
	end
end

function OnClientListen(id: string, ...)
	if Listeners[id] == nil then
		warn(ErrorMessage, "Client_Error", id)
		return
	end

	if Listeners[id] then
		return Listeners[id].Callback(...)
	end

end

function OnComListen(id: string, ...)
	if Listeners[id] == nil then
		warn(ErrorMessage, "Bindable_Error", id)
		return
	end

	if Listeners[id] then
		return Listeners[id].Callback(...)
	end

end

BindableEvent.Event:Connect(OnComListen)
BindableFunc.OnInvoke = OnComListen

if RS:IsServer() then
	RemoteEvent.OnServerEvent:Connect(OnServerListen)
	RemoteFunc.OnServerInvoke = OnServerListen
elseif RS:IsClient() then
	RemoteEvent.OnClientEvent:Connect(OnClientListen)
	RemoteFunc.OnClientInvoke = OnClientListen
end

return module
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="19">
          <Properties>
            <string name="Name">ServerApi</string>
          </Properties>
          <Item class="ModuleScript" referent="20">
            <Properties>
              <string name="Name">IsServer</string>
              <string name="Source"><![CDATA[
local module = {}

function module:IsPrivateServer()
	if game.PrivateServerOwnerId ~= 0 and game.PrivateServerId ~= "" then
		return true
	end
end

function module:IsReserveServer()
	if game.PrivateServerId ~= "" and game.PrivateServerOwnerId == 0 then
		return true
	end
end

function module.PrivateServerStarted(handler)
	if not module:IsPrivateServer() then
		return
	end

	game.Players.PlayerAdded:Connect(function(player)
		if game.PrivateServerOwnerId == player.UserId then
			handler(player)
		end
	end)
	
end

function module.ReserveServerStarted(handler)
	if not module:IsReserveServer() then
		return
	end
	
	game.Players.PlayerAdded:Connect(function(player)
		handler(player)
	end)
	
end

return module]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="21">
            <Properties>
              <string name="Name">TeamClass</string>
              <string name="Source">local module = {}
local Players = game:GetService("Players")
local RS = game:GetService("RunService")

local CurrentTeam = {}
local Teams = {}

function module:SwitchTeam(player: Player, team:Team)
	CurrentTeam[player.UserId] = player.Team
	RS.Heartbeat:Wait()
	player.Team = team
	return "New Team: "..team.Name
end

function module:ReturnToFormerTeam(player: Player)
	if CurrentTeam[player.UserId] ~= nil then
		player.Team = CurrentTeam[player.UserId]
		return player.Name.." returned to previous team. "..CurrentTeam[player.UserId].Name
	end
end

return module</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="ServerScriptService" referent="22">
      <Properties>
        <string name="Name">ServerScriptService</string>
      </Properties>
      <Item class="Script" referent="23">
        <Properties>
          <string name="Name">IsServer</string>
          <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)
local IsServer = UAF.IsServer

if IsServer:IsPrivateServer() then
    print("its a private server")
end

if IsServer:IsReserveServer() then
    print("its a reserved server")
end

IsServer:PrivateServerStarted(function(player)
    print(player.Name, "is the owner")
end)

IsServer:ReserveServerStarted(function()
    print("functio run here")
end)</string>
        </Properties>
      </Item>
      <Item class="Script" referent="24">
        <Properties>
          <string name="Name">Numbers</string>
          <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)
local Numbers = UAF.Numbers

-- Finding The Average
local Average = Numbers:GetAverage(1, 2, 3, 4)
print("the average is:", Average)

-- Check if its even
local Even = Numbers:IsEven(2)
if Even then
    print("number is event")
else
    print("number is not event")
end

-- Adding Numbers
local GetAddTotal = Numbers:Add(1, 2, 3)
print("The Total added is:", GetAddTotal)

-- Multiplying Numbers
local GetMulTotal = Numbers:Multiply(11, 22, 33)
print("The Total multiplyed is:", GetMulTotal)</string>
        </Properties>
      </Item>
      <Item class="Script" referent="25">
        <Properties>
          <string name="Name">Receive</string>
          <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)
local Event = UAF.Event

Event:ListenForEvent("hello", function(player, number)
    for index, value in pairs(number) do
        print("Wallet:", index, value)
    end
end)</string>
        </Properties>
      </Item>
    </Item>
    <Item class="StarterGui" referent="26">
      <Properties>
        <string name="Name">StarterGui</string>
      </Properties>
      <Item class="LocalScript" referent="27">
        <Properties>
          <string name="Name">GuiClass</string>
          <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)
local GuiClass = UAF.GuiClass

function callback()
    print("works")
end

GuiClass:EditTextButton({
    Callback = callback,
    MouseEnterCallback = callback,
    MouseExitCallback = callback
})

GuiClass:EditFrame({
    MouseExitCallback = callback,
    MouseEnterCallback = callback
})

GuiClass:EditGeneralButton({
    Callback = callback,
    MouseEnterCallback = callback,
    MouseExitCallback = callback
})

GuiClass:EditImage({
    Image = "rbxassetid://"..1,
})

GuiClass:EditImageButton({
    Callback = callback,
    MouseEnterCallback = callback,
    MouseExitCallback = callback,
    HoverImage = "rbxassetid://"..1,
    Image = "rbxassetid://"..1
})</string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="28">
        <Properties>
          <string name="Name">InputClass</string>
          <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)
local InputClass = UAF.InputClass

function callback()
    print("Got the command")
end

-- Binding Keys
InputClass:CombineKey("test", callback, Enum.KeyCode.LeftControl, Enum.KeyCode.LeftShift, Enum.KeyCode.C)

-- Unbinding Keys
InputClass:UnbindKey("test")

-- Registering Input
InputClass:BeginInput({
    Proccessed = true,
    Key = Enum.KeyCode.A,
    Callback = callback
})

InputClass:ChangeInput({
    Proccessed = true,
    Key = Enum.KeyCode.C,
    Callback = callback,
})

InputClass:EndInput({
    Proccessed = true,
    Key = Enum.KeyCode.C,
    Callback = callback
})</string>
        </Properties>
      </Item>
    </Item>
    <Item class="StarterPlayer" referent="29">
      <Properties>
        <string name="Name">StarterPlayer</string>
      </Properties>
      <Item class="StarterCharacterScripts" referent="30">
        <Properties>
          <string name="Name">StarterCharacterScripts</string>
        </Properties>
        <Item class="LocalScript" referent="31">
          <Properties>
            <string name="Name">Testing</string>
            <string name="Source">local BitCoins = {
    Balance = 10,
    Wallet = 90,
    Withdraw = 100,
}

local Player = game.Players.LocalPlayer
local UAF = require(game.ReplicatedStorage.UAFramework)
local Event = UAF.Event

if script.Parent:FindFirstChildOfClass("Humanoid") then
    Event:SendServer("hello", BitCoins)
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="StarterPlayerScripts" referent="32">
        <Properties>
          <string name="Name">StarterPlayerScripts</string>
        </Properties>
        <Item class="LocalScript" referent="33">
          <Properties>
            <string name="Name">player_testing</string>
            <string name="Source">local UAF = require(game.ReplicatedStorage.UAFramework)</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>